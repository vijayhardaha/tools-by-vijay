"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/deepmerge-ts";
exports.ids = ["vendor-chunks/deepmerge-ts"];
exports.modules = {

/***/ "(ssr)/../node_modules/deepmerge-ts/dist/index.mjs":
/*!***************************************************!*\
  !*** ../node_modules/deepmerge-ts/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepmerge: () => (/* binding */ deepmerge),\n/* harmony export */   deepmergeCustom: () => (/* binding */ deepmergeCustom),\n/* harmony export */   deepmergeInto: () => (/* binding */ deepmergeInto),\n/* harmony export */   deepmergeIntoCustom: () => (/* binding */ deepmergeIntoCustom),\n/* harmony export */   getKeys: () => (/* binding */ getKeys),\n/* harmony export */   getObjectType: () => (/* binding */ getObjectType),\n/* harmony export */   objectHasProperty: () => (/* binding */ objectHasProperty)\n/* harmony export */ });\n/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    let m_iterablesIndex = 0;\n    let m_iterator = iterables[0]?.[Symbol.iterator]();\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    do {\n                        if (m_iterator === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const result = m_iterator.next();\n                        if (result.done === true) {\n                            m_iterablesIndex += 1;\n                            m_iterator = iterables[m_iterablesIndex]?.[Symbol.iterator]();\n                            continue;\n                        }\n                        return {\n                            done: false,\n                            value: result.value,\n                        };\n                    } while (true);\n                },\n            };\n        },\n    };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last non-undefined value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(m_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(m_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            m_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(m_target, values) {\n    m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(m_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        m_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(m_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        m_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last non-undefined value.\n */\nfunction mergeOthersInto$1(m_target, values) {\n    m_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(m_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(m_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(m_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(m_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(m_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(m_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(m_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(m_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(m_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(m_target, values);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS10cy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxSCIsInNvdXJjZXMiOlsiL1VzZXJzL3Npbi9yZXBvcy90b29scy1ieS12aWpheS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlLXRzL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3BlY2lhbCB2YWx1ZXMgdGhhdCB0ZWxsIGRlZXBtZXJnZSB0byBwZXJmb3JtIGEgY2VydGFpbiBhY3Rpb24uXG4gKi9cbmNvbnN0IGFjdGlvbnMgPSB7XG4gICAgZGVmYXVsdE1lcmdlOiBTeW1ib2woXCJkZWVwbWVyZ2UtdHM6IGRlZmF1bHQgbWVyZ2VcIiksXG4gICAgc2tpcDogU3ltYm9sKFwiZGVlcG1lcmdlLXRzOiBza2lwXCIpLFxufTtcbi8qKlxuICogU3BlY2lhbCB2YWx1ZXMgdGhhdCB0ZWxsIGRlZXBtZXJnZUludG8gdG8gcGVyZm9ybSBhIGNlcnRhaW4gYWN0aW9uLlxuICovXG5jb25zdCBhY3Rpb25zSW50byA9IHtcbiAgICBkZWZhdWx0TWVyZ2U6IGFjdGlvbnMuZGVmYXVsdE1lcmdlLFxufTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byB1cGRhdGUgbWV0YSBkYXRhLlxuICpcbiAqIEl0IGRvZXNuJ3QgdXBkYXRlIHRoZSBtZXRhIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRNZXRhRGF0YVVwZGF0ZXIocHJldmlvdXNNZXRhLCBtZXRhTWV0YSkge1xuICAgIHJldHVybiBtZXRhTWV0YTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gZmlsdGVyIHZhbHVlcy5cbiAqXG4gKiBJdCBmaWx0ZXJzIG91dCB1bmRlZmluZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyVmFsdWVzKHZhbHVlcywgbWV0YSkge1xuICAgIHJldHVybiB2YWx1ZXMuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCk7XG59XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBvYmplY3RzIGRlZXBtZXJnZS10cyBzdXBwb3J0LlxuICovXG52YXIgT2JqZWN0VHlwZTtcbihmdW5jdGlvbiAoT2JqZWN0VHlwZSkge1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIk5PVFwiXSA9IDBdID0gXCJOT1RcIjtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJSRUNPUkRcIl0gPSAxXSA9IFwiUkVDT1JEXCI7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiQVJSQVlcIl0gPSAyXSA9IFwiQVJSQVlcIjtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJTRVRcIl0gPSAzXSA9IFwiU0VUXCI7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiTUFQXCJdID0gNF0gPSBcIk1BUFwiO1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIk9USEVSXCJdID0gNV0gPSBcIk9USEVSXCI7XG59KShPYmplY3RUeXBlIHx8IChPYmplY3RUeXBlID0ge30pKTtcbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gZ2V0IHRoZSB0eXBlIG9mLlxuICogQHJldHVybnMgVGhlIHR5cGUgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0T2JqZWN0VHlwZShvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIiB8fCBvYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogT2JqZWN0VHlwZS5OT1QgKi87XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIDIgLyogT2JqZWN0VHlwZS5BUlJBWSAqLztcbiAgICB9XG4gICAgaWYgKGlzUmVjb3JkKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogT2JqZWN0VHlwZS5SRUNPUkQgKi87XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIDMgLyogT2JqZWN0VHlwZS5TRVQgKi87XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuIDQgLyogT2JqZWN0VHlwZS5NQVAgKi87XG4gICAgfVxuICAgIHJldHVybiA1IC8qIE9iamVjdFR5cGUuT1RIRVIgKi87XG59XG4vKipcbiAqIEdldCB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0cyBpbmNsdWRpbmcgc3ltYm9sIGtleXMuXG4gKlxuICogTm90ZTogT25seSBrZXlzIHRvIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHRvIGdldCB0aGUga2V5cyBvZi5cbiAqIEByZXR1cm5zIEEgc2V0IGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIG9mIGFsbCB0aGUgZ2l2ZW4gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhvYmplY3RzKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBvYmplY3RzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi5PYmplY3Qua2V5cyhvYmplY3QpLCAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCldKSB7XG4gICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBEb2VzIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEBwYXJhbSBwcm9wZXJ0eSAtIFRoZSBwcm9wZXJ0eSB0byB0ZXN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdEhhc1Byb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG59XG4vKipcbiAqIEdldCBhbiBpdGVyYWJsZSBvYmplY3QgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiBpdGVyYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhYmxlT2ZJdGVyYWJsZXMoaXRlcmFibGVzKSB7XG4gICAgbGV0IG1faXRlcmFibGVzSW5kZXggPSAwO1xuICAgIGxldCBtX2l0ZXJhdG9yID0gaXRlcmFibGVzWzBdPy5bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobV9pdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbV9pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtX2l0ZXJhYmxlc0luZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbV9pdGVyYXRvciA9IGl0ZXJhYmxlc1ttX2l0ZXJhYmxlc0luZGV4XT8uW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItc2V0LWhhcyAtLSBBcnJheSBpcyBtb3JlIHBlcmZvcm1hbnQgZm9yIGEgbG93IG51bWJlciBvZiBlbGVtZW50cy5cbmNvbnN0IHZhbGlkUmVjb3JkVG9TdHJpbmdWYWx1ZXMgPSBbXCJbb2JqZWN0IE9iamVjdF1cIiwgXCJbb2JqZWN0IE1vZHVsZV1cIl07XG4vKipcbiAqIERvZXMgdGhlIGdpdmVuIG9iamVjdCBhcHBlYXIgdG8gYmUgYSByZWNvcmQuXG4gKi9cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gICAgLy8gQWxsIHJlY29yZHMgYXJlIG9iamVjdHMuXG4gICAgaWYgKCF2YWxpZFJlY29yZFRvU3RyaW5nVmFsdWVzLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gdmFsdWU7XG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB0cy9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIC8vIElmIGhhcyBtb2RpZmllZCBwcm90b3R5cGUuXG4gICAgaWYgKHByb3RvdHlwZSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgcHJvdG90eXBlICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICF2YWxpZFJlY29yZFRvU3RyaW5nVmFsdWVzLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm90b3R5cGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29uYXIvcHJlZmVyLXNpbmdsZS1ib29sZWFuLXJldHVybiwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgaWYgKCFwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gTW9zdCBsaWtlbHkgYSByZWNvcmQuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgcmVjb3Jkcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHJlY29yZHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3JkcyQxKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBnZXRLZXlzKHZhbHVlcykpIHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKG9iamVjdEhhc1Byb3BlcnR5KHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlcy5wdXNoKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZE1ldGEgPSB1dGlscy5tZXRhRGF0YVVwZGF0ZXIobWV0YSwge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcGFyZW50czogdmFsdWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlSZXN1bHQgPSBtZXJnZVVua25vd25zKHByb3BWYWx1ZXMsIHV0aWxzLCB1cGRhdGVkTWV0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eVJlc3VsdCA9PT0gYWN0aW9ucy5za2lwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcGVydHlSZXN1bHQsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJvcGVydHlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyQxKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMuZmxhdCgpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBzZXRzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTZXRzJDEodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMpKTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgdG8gbWVyZ2UgbWFwcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwcyQxKHZhbHVlcykge1xuICAgIHJldHVybiBuZXcgTWFwKGdldEl0ZXJhYmxlT2ZJdGVyYWJsZXModmFsdWVzKSk7XG59XG4vKipcbiAqIEdldCB0aGUgbGFzdCBub24tdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPdGhlcnMkMSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLmF0KC0xKTtcbn1cbi8qKlxuICogVGhlIG1lcmdlIGZ1bmN0aW9ucy5cbiAqL1xuY29uc3QgbWVyZ2VGdW5jdGlvbnMgPSB7XG4gICAgbWVyZ2VSZWNvcmRzOiBtZXJnZVJlY29yZHMkMSxcbiAgICBtZXJnZUFycmF5czogbWVyZ2VBcnJheXMkMSxcbiAgICBtZXJnZVNldHM6IG1lcmdlU2V0cyQxLFxuICAgIG1lcmdlTWFwczogbWVyZ2VNYXBzJDEsXG4gICAgbWVyZ2VPdGhlcnM6IG1lcmdlT3RoZXJzJDEsXG59O1xuXG4vKipcbiAqIERlZXBseSBtZXJnZSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBvYmplY3RzIC0gVGhlIG9iamVjdHMgdG8gbWVyZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlZXBtZXJnZSguLi5vYmplY3RzKSB7XG4gICAgcmV0dXJuIGRlZXBtZXJnZUN1c3RvbSh7fSkoLi4ub2JqZWN0cyk7XG59XG5mdW5jdGlvbiBkZWVwbWVyZ2VDdXN0b20ob3B0aW9ucywgcm9vdE1ldGFEYXRhKSB7XG4gICAgY29uc3QgdXRpbHMgPSBnZXRVdGlscyhvcHRpb25zLCBjdXN0b21pemVkRGVlcG1lcmdlKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VzdG9taXplZCBkZWVwbWVyZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9taXplZERlZXBtZXJnZSguLi5vYmplY3RzKSB7XG4gICAgICAgIHJldHVybiBtZXJnZVVua25vd25zKG9iamVjdHMsIHV0aWxzLCByb290TWV0YURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY3VzdG9taXplZERlZXBtZXJnZTtcbn1cbi8qKlxuICogVGhlIHRoZSB1dGlscyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gdGhlIG1lcmdlIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRoZSB1c2VyIHNwZWNpZmllZFxuICovXG5mdW5jdGlvbiBnZXRVdGlscyhvcHRpb25zLCBjdXN0b21pemVkRGVlcG1lcmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdE1lcmdlRnVuY3Rpb25zOiBtZXJnZUZ1bmN0aW9ucyxcbiAgICAgICAgbWVyZ2VGdW5jdGlvbnM6IHtcbiAgICAgICAgICAgIC4uLm1lcmdlRnVuY3Rpb25zLFxuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW2tleSwgb3B0aW9uXSkgPT4gT2JqZWN0Lmhhc093bihtZXJnZUZ1bmN0aW9ucywga2V5KSlcbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCBvcHRpb25dKSA9PiAob3B0aW9uID09PSBmYWxzZSA/IFtrZXksIG1lcmdlRnVuY3Rpb25zLm1lcmdlT3RoZXJzXSA6IFtrZXksIG9wdGlvbl0pKSksXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFEYXRhVXBkYXRlcjogKG9wdGlvbnMubWV0YURhdGFVcGRhdGVyID8/IGRlZmF1bHRNZXRhRGF0YVVwZGF0ZXIpLFxuICAgICAgICBkZWVwbWVyZ2U6IGN1c3RvbWl6ZWREZWVwbWVyZ2UsXG4gICAgICAgIHVzZUltcGxpY2l0RGVmYXVsdE1lcmdpbmc6IG9wdGlvbnMuZW5hYmxlSW1wbGljaXREZWZhdWx0TWVyZ2luZyA/PyBmYWxzZSxcbiAgICAgICAgZmlsdGVyVmFsdWVzOiBvcHRpb25zLmZpbHRlclZhbHVlcyA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiAob3B0aW9ucy5maWx0ZXJWYWx1ZXMgPz8gZGVmYXVsdEZpbHRlclZhbHVlcyksXG4gICAgICAgIGFjdGlvbnMsXG4gICAgfTtcbn1cbi8qKlxuICogTWVyZ2UgdW5rbm93biB0aGluZ3MuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlVW5rbm93bnModmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGZpbHRlcmVkVmFsdWVzID0gdXRpbHMuZmlsdGVyVmFsdWVzPy4odmFsdWVzLCBtZXRhKSA/PyB2YWx1ZXM7XG4gICAgaWYgKGZpbHRlcmVkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyZWRWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBtZXJnZU90aGVycyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZ2V0T2JqZWN0VHlwZShmaWx0ZXJlZFZhbHVlc1swXSk7XG4gICAgaWYgKHR5cGUgIT09IDAgLyogT2JqZWN0VHlwZS5OT1QgKi8gJiYgdHlwZSAhPT0gNSAvKiBPYmplY3RUeXBlLk9USEVSICovKSB7XG4gICAgICAgIGZvciAobGV0IG1faW5kZXggPSAxOyBtX2luZGV4IDwgZmlsdGVyZWRWYWx1ZXMubGVuZ3RoOyBtX2luZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChnZXRPYmplY3RUeXBlKGZpbHRlcmVkVmFsdWVzW21faW5kZXhdKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlT3RoZXJzKGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBPYmplY3RUeXBlLlJFQ09SRCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlUmVjb3JkcyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBPYmplY3RUeXBlLkFSUkFZICovOiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VBcnJheXMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogT2JqZWN0VHlwZS5TRVQgKi86IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZVNldHMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDQgLyogT2JqZWN0VHlwZS5NQVAgKi86IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZU1hcHMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPdGhlcnMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgcmVjb3Jkcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHJlY29yZHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3Jkcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlUmVjb3Jkcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2UgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXModmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gYWN0aW9ucy5kZWZhdWx0TWVyZ2UgfHxcbiAgICAgICAgKHV0aWxzLnVzZUltcGxpY2l0RGVmYXVsdE1lcmdpbmcgJiZcbiAgICAgICAgICAgIHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyAhPT0gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIHNldHMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHModmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBhY3Rpb25zLmRlZmF1bHRNZXJnZSB8fFxuICAgICAgICAodXRpbHMudXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZyAmJlxuICAgICAgICAgICAgcmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyAhPT0gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cykpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZVNldHModmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2UgbWFwcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG1hcHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwcyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZSBvdGhlciB0aGluZ3MuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBvdGhlciB0aGluZ3MuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3RoZXJzKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBhY3Rpb25zLmRlZmF1bHRNZXJnZSB8fFxuICAgICAgICAodXRpbHMudXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZyAmJlxuICAgICAgICAgICAgcmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlT3RoZXJzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnMpKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnModmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSByZWNvcmRzIGludG8gYSB0YXJnZXQgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSByZXN1bHQgd2lsbCBiZSBtdXRhdGVkIGludG8gdGhpcyByZWNvcmRcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgcmVjb3JkcyAoaW5jbHVkaW5nIHRoZSB0YXJnZXQncyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUpLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlY29yZHNJbnRvJDEobV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBnZXRLZXlzKHZhbHVlcykpIHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKG9iamVjdEhhc1Byb3BlcnR5KHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlcy5wdXNoKHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZE1ldGEgPSB1dGlscy5tZXRhRGF0YVVwZGF0ZXIobWV0YSwge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcGFyZW50czogdmFsdWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUYXJnZXQgPSB7IHZhbHVlOiBwcm9wVmFsdWVzWzBdIH07XG4gICAgICAgIG1lcmdlVW5rbm93bnNJbnRvKHByb3BlcnR5VGFyZ2V0LCBwcm9wVmFsdWVzLCB1dGlscywgdXBkYXRlZE1ldGEpO1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobV90YXJnZXQudmFsdWUsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0eVRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbV90YXJnZXQudmFsdWVba2V5XSA9IHByb3BlcnR5VGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBhcnJheXMgaW50byBhIHRhcmdldCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gbV90YXJnZXQgLSBUaGUgcmVzdWx0IHdpbGwgYmUgbXV0YXRlZCBpbnRvIHRoaXMgYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzIChpbmNsdWRpbmcgdGhlIHRhcmdldCdzIHZhbHVlIGlmIHRoZXJlIGlzIG9uZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXJyYXlzSW50byQxKG1fdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBtX3RhcmdldC52YWx1ZS5wdXNoKC4uLnZhbHVlcy5zbGljZSgxKS5mbGF0KCkpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBzZXRzIGludG8gYSB0YXJnZXQgc2V0LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSByZXN1bHQgd2lsbCBiZSBtdXRhdGVkIGludG8gdGhpcyBzZXRcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0cyAoaW5jbHVkaW5nIHRoZSB0YXJnZXQncyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUpLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHNJbnRvJDEobV90YXJnZXQsIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMuc2xpY2UoMSkpKSB7XG4gICAgICAgIG1fdGFyZ2V0LnZhbHVlLmFkZCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBtYXBzIGludG8gYSB0YXJnZXQgbWFwLlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSByZXN1bHQgd2lsbCBiZSBtdXRhdGVkIGludG8gdGhpcyBtYXBcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgbWFwcyAoaW5jbHVkaW5nIHRoZSB0YXJnZXQncyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUpLlxuICovXG5mdW5jdGlvbiBtZXJnZU1hcHNJbnRvJDEobV90YXJnZXQsIHZhbHVlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGdldEl0ZXJhYmxlT2ZJdGVyYWJsZXModmFsdWVzLnNsaWNlKDEpKSkge1xuICAgICAgICBtX3RhcmdldC52YWx1ZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHRhcmdldCB0byB0aGUgbGFzdCBub24tdW5kZWZpbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBtZXJnZU90aGVyc0ludG8kMShtX3RhcmdldCwgdmFsdWVzKSB7XG4gICAgbV90YXJnZXQudmFsdWUgPSB2YWx1ZXMuYXQoLTEpO1xufVxuLyoqXG4gKiBUaGUgbWVyZ2UgZnVuY3Rpb25zLlxuICovXG5jb25zdCBtZXJnZUludG9GdW5jdGlvbnMgPSB7XG4gICAgbWVyZ2VSZWNvcmRzOiBtZXJnZVJlY29yZHNJbnRvJDEsXG4gICAgbWVyZ2VBcnJheXM6IG1lcmdlQXJyYXlzSW50byQxLFxuICAgIG1lcmdlU2V0czogbWVyZ2VTZXRzSW50byQxLFxuICAgIG1lcmdlTWFwczogbWVyZ2VNYXBzSW50byQxLFxuICAgIG1lcmdlT3RoZXJzOiBtZXJnZU90aGVyc0ludG8kMSxcbn07XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZUludG8odGFyZ2V0LCAuLi5vYmplY3RzKSB7XG4gICAgcmV0dXJuIHZvaWQgZGVlcG1lcmdlSW50b0N1c3RvbSh7fSkodGFyZ2V0LCAuLi5vYmplY3RzKTtcbn1cbmZ1bmN0aW9uIGRlZXBtZXJnZUludG9DdXN0b20ob3B0aW9ucywgcm9vdE1ldGFEYXRhKSB7XG4gICAgY29uc3QgdXRpbHMgPSBnZXRJbnRvVXRpbHMob3B0aW9ucywgY3VzdG9taXplZERlZXBtZXJnZUludG8pO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXN0b21pemVkIGRlZXBtZXJnZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21pemVkRGVlcG1lcmdlSW50byh0YXJnZXQsIC4uLm9iamVjdHMpIHtcbiAgICAgICAgbWVyZ2VVbmtub3duc0ludG8oeyB2YWx1ZTogdGFyZ2V0IH0sIFt0YXJnZXQsIC4uLm9iamVjdHNdLCB1dGlscywgcm9vdE1ldGFEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1c3RvbWl6ZWREZWVwbWVyZ2VJbnRvO1xufVxuLyoqXG4gKiBUaGUgdGhlIHV0aWxzIHRoYXQgYXJlIGF2YWlsYWJsZSB0byB0aGUgbWVyZ2UgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdGhlIHVzZXIgc3BlY2lmaWVkXG4gKi9cbmZ1bmN0aW9uIGdldEludG9VdGlscyhvcHRpb25zLCBjdXN0b21pemVkRGVlcG1lcmdlSW50bykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRNZXJnZUZ1bmN0aW9uczogbWVyZ2VJbnRvRnVuY3Rpb25zLFxuICAgICAgICBtZXJnZUZ1bmN0aW9uczoge1xuICAgICAgICAgICAgLi4ubWVyZ2VJbnRvRnVuY3Rpb25zLFxuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW2tleSwgb3B0aW9uXSkgPT4gT2JqZWN0Lmhhc093bihtZXJnZUludG9GdW5jdGlvbnMsIGtleSkpXG4gICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgb3B0aW9uXSkgPT4gKG9wdGlvbiA9PT0gZmFsc2UgPyBba2V5LCBtZXJnZUludG9GdW5jdGlvbnMubWVyZ2VPdGhlcnNdIDogW2tleSwgb3B0aW9uXSkpKSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YURhdGFVcGRhdGVyOiAob3B0aW9ucy5tZXRhRGF0YVVwZGF0ZXIgPz8gZGVmYXVsdE1ldGFEYXRhVXBkYXRlciksXG4gICAgICAgIGRlZXBtZXJnZUludG86IGN1c3RvbWl6ZWREZWVwbWVyZ2VJbnRvLFxuICAgICAgICBmaWx0ZXJWYWx1ZXM6IG9wdGlvbnMuZmlsdGVyVmFsdWVzID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IChvcHRpb25zLmZpbHRlclZhbHVlcyA/PyBkZWZhdWx0RmlsdGVyVmFsdWVzKSxcbiAgICAgICAgYWN0aW9uczogYWN0aW9uc0ludG8sXG4gICAgfTtcbn1cbi8qKlxuICogTWVyZ2UgdW5rbm93biB0aGluZ3MgaW50byBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gbV90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VVbmtub3duc0ludG8obV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFZhbHVlcyA9IHV0aWxzLmZpbHRlclZhbHVlcz8uKHZhbHVlcywgbWV0YSkgPz8gdmFsdWVzO1xuICAgIGlmIChmaWx0ZXJlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmlsdGVyZWRWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB2b2lkIG1lcmdlT3RoZXJzSW50byhtX3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IGdldE9iamVjdFR5cGUobV90YXJnZXQudmFsdWUpO1xuICAgIGlmICh0eXBlICE9PSAwIC8qIE9iamVjdFR5cGUuTk9UICovICYmIHR5cGUgIT09IDUgLyogT2JqZWN0VHlwZS5PVEhFUiAqLykge1xuICAgICAgICBmb3IgKGxldCBtX2luZGV4ID0gMTsgbV9pbmRleCA8IGZpbHRlcmVkVmFsdWVzLmxlbmd0aDsgbV9pbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoZ2V0T2JqZWN0VHlwZShmaWx0ZXJlZFZhbHVlc1ttX2luZGV4XSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlT3RoZXJzSW50byhtX3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIE9iamVjdFR5cGUuUkVDT1JEICovOiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZVJlY29yZHNJbnRvKG1fdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBPYmplY3RUeXBlLkFSUkFZICovOiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZUFycmF5c0ludG8obV90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzIC8qIE9iamVjdFR5cGUuU0VUICovOiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZVNldHNJbnRvKG1fdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBPYmplY3RUeXBlLk1BUCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VNYXBzSW50byhtX3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZU90aGVyc0ludG8obV90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIHJlY29yZHMgaW50byBhIHRhcmdldCByZWNvcmQuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBtZXJnZSBpbnRvLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSByZWNvcmRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlY29yZHNJbnRvKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlUmVjb3JkcyhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSBhcnJheXMgaW50byBhIHRhcmdldCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gbV90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXNJbnRvKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXMobV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChhY3Rpb24gPT09IGFjdGlvbnNJbnRvLmRlZmF1bHRNZXJnZSkge1xuICAgICAgICB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXMobV90YXJnZXQsIHZhbHVlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSBzZXRzIGludG8gYSB0YXJnZXQgc2V0LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VTZXRzSW50byhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKGFjdGlvbiA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZVNldHMobV90YXJnZXQsIHZhbHVlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSBtYXBzIGludG8gYSB0YXJnZXQgbWFwLlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgbWFwcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBzSW50byhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGFjdGlvbiA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKGFjdGlvbiA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU1hcHMobV90YXJnZXQsIHZhbHVlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSBvdGhlciB0aGluZ3MgaW50byBhIHRhcmdldC5cbiAqXG4gKiBAcGFyYW0gbV90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG90aGVyIHRoaW5ncy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPdGhlcnNJbnRvKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnMobV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChhY3Rpb24gPT09IGFjdGlvbnNJbnRvLmRlZmF1bHRNZXJnZSB8fCBtX3RhcmdldC52YWx1ZSA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyhtX3RhcmdldCwgdmFsdWVzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRlZXBtZXJnZSwgZGVlcG1lcmdlQ3VzdG9tLCBkZWVwbWVyZ2VJbnRvLCBkZWVwbWVyZ2VJbnRvQ3VzdG9tLCBnZXRLZXlzLCBnZXRPYmplY3RUeXBlLCBvYmplY3RIYXNQcm9wZXJ0eSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/deepmerge-ts/dist/index.mjs\n");

/***/ })

};
;